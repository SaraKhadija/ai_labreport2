# -*- coding: utf-8 -*-
"""AI LAB REPORT 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NVORUfYAyUSQzLK4WXjKwe0abDbLz-xO
"""

import random

# --- GA Parameters ---
POPULATION_SIZE = 300
INDIVIDUAL_LENGTH = 80
GENERATIONS = 50

# --- Problem-Specific Parameters ---
# The function is maximized when the number of '1's equals 50
TARGET_ONES = 50
# When the number of '1's equals 50, the return value (fitness) is 80
MAX_FITNESS = 80

# --- Hyperparameters (Commonly used in GA) ---
MUTATION_RATE = 0.05
ELITISM_COUNT = 1

def create_individual(length):
    """Generates a random bit pattern (list of 0s and 1s)."""
    return [random.randint(0, 1) for _ in range(length)]

def initialize_population(pop_size, length):
    """Creates the initial population of individuals."""
    return [create_individual(length) for _ in range(pop_size)]

def calculate_fitness(individual):
    """
    Calculates the fitness based on the number of '1's.
    Max fitness (80) is achieved when the '1's count is 50.
    """
    ones_count = sum(individual)

    if ones_count == TARGET_ONES:
        # Condition 4: When '1's count is 50, return value is 80
        return MAX_FITNESS
    else:
        # Calculate fitness based on the absolute difference from the target.
        # Max distance from 50 is 50 (for 0 '1's or 80 '1's).
        # We subtract the absolute difference from MAX_FITNESS to reward closeness to TARGET_ONES.
        distance = abs(ones_count - TARGET_ONES)

        # A simple linear model: 80 - distance, so fitness ranges from 80 (distance 0) down to 30 (distance 50).
        return MAX_FITNESS - distance

def run_genetic_algorithm():
    """
    The main GA loop runs for 50 generations.
    """

    # 1. Initialize Population (Condition 1: Population is 300)
    population = initialize_population(POPULATION_SIZE, INDIVIDUAL_LENGTH)

    # Track the best solution found
    best_individual = None
    best_fitness = -1

    # 2. Iterate through Generations (Condition 5: 50 generations)
    print(f"Starting Genetic Algorithm for {GENERATIONS} generations...")
    print(f"Target: {TARGET_ONES} ones for Max Fitness: {MAX_FITNESS}")

    for generation in range(1, GENERATIONS + 1):
        # Evaluate fitness for the current population
        fitnesses = [(individual, calculate_fitness(individual)) for individual in population]

        # Sort individuals by fitness (descending)
        fitnesses.sort(key=lambda x: x[1], reverse=True)

        current_best_individual, current_best_fitness = fitnesses[0]

        # Update overall best
        if current_best_fitness > best_fitness:
            best_fitness = current_best_fitness
            best_individual = current_best_individual

        # Print status every 10 generations
        if generation % 10 == 0 or generation == 1:
            print(f"\nGeneration {generation}:")
            print(f"  Best Fitness: {current_best_fitness}")
            print(f"  '1's Count: {sum(current_best_individual)}")

        # --- Reproduction Steps (Selection, Crossover, Mutation) ---

        # 3. Selection (e.g., Elitism and Tournament/Roulette Wheel)
        new_population = [ind for ind, fit in fitnesses[:ELITISM_COUNT]] # Elitism: keep the best

        # The following lines are placeholders for the full reproduction process:
        while len(new_population) < POPULATION_SIZE:
            # Placeholder for Parent Selection (e.g., Tournament Selection)
            parent1 = fitnesses[random.randint(0, POPULATION_SIZE-1)][0]
            parent2 = fitnesses[random.randint(0, POPULATION_SIZE-1)][0]

            # Placeholder for Crossover (e.g., Single-Point Crossover)
            crossover_point = random.randint(1, INDIVIDUAL_LENGTH - 1)
            child = parent1[:crossover_point] + parent2[crossover_point:]

            # Placeholder for Mutation (Flip a bit with a low probability)
            if random.random() < MUTATION_RATE:
                mutation_point = random.randint(0, INDIVIDUAL_LENGTH - 1)
                child[mutation_point] = 1 - child[mutation_point] # Flip the bit

            new_population.append(child)

        population = new_population

    # --- Final Result ---
    print("\n" + "="*40)
    print("✨ GA Simulation Complete ✨")
    print(f"Target: {TARGET_ONES} '1's for a fitness of {MAX_FITNESS}")
    print(f"\nFinal Best Fitness Found: **{best_fitness}**")
    print(f"Final Best '1's Count: **{sum(best_individual)}**")
    print(f"Best Bit Pattern (Length {INDIVIDUAL_LENGTH}):")
    print("".join(map(str, best_individual)))
    print("="*40)

    # Return the best individual found
    return best_individual

if __name__ == "__main__":
    final_solution = run_genetic_algorithm()